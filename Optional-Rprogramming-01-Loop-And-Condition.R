#R有許多向量化運算，可以避免寫迴圈的麻煩
#但是有時我們還是需要透過迴圈實現自己想要的功能
#迴圈的功能就是不斷重複做同樣的動作，省去同個動作要做好幾次的麻煩
#機器學習中就是使用迴圈來不停重複且優化每個步驟的結果

#for迴圈主要是在運算前就清楚迭代次數的情況
#實現f(x) = x^2的值為最小，雖然知道答案是0，但仍使用數值方法來逼近
y <- c(rep(1,100)) #因為要重複99次，所以包含第一個向量總共需要100個向量
for (i in 1:99) {   #重複99次
    y[1] =  3      #假設第一個數值向量為3
    y[i+1] = y[i] - 0.2 * y[i] }  #開始執行第i次迴圈
y #輸出後發現愈後面數值愈接近0

y[2] = y[1] - 0.2*y[1]; y[3] = y[2] - 0.2*y[2]; y[4] = y[3] - 0.2*y[3]
#前三次重複的動作就如同上式，下一個值為本值扣掉0.2乘以本值
#迴圈的功能就是不斷的重複你要的動作，直到次數到達為止
#當然第一個數值向量也可以不用假設3，從1開始也可以
#對於扣掉0.2倍只是主觀上認為在每次迴圈可以改善答案的方法
#我們的目的是要接近'0'，這與我們直覺上認為0就是答案是大相徑庭的
#機器學習中'優化'就是類似這樣不斷的改善既有答案
#能夠考慮的是數字之間的距離abs，當距離小於某個幅度時，就停止迴圈
y <- c(rep(1,100))
for (i in 1:99) {   #重複99次
    y[1] =  3      #假設第一個數值向量為3
    y[i+1] = y[i] - 0.2 * y[i] 
    if (abs(y[i+1]-y[i] < 0.01))break
}
y  #看出到了第20個數值向量就停止迴圈
#repeat一樣不斷重複程式碼，直到break中斷執行
z <- 1
repeat{
    z = z - 0.2 * z
    if (round(z,digits = 1) != 0) next
    message(z)
    if (round(z,digits = 3) == 0) break
}
#next能夠讓程式碼依照if條件跳過當次的迭代
#break設定的條件比較清晰，小數點後第三位為0時即停止迴圈

a <- 1
while (round(a,digits = 3) != 0) {
    a = a - 0.2 * a
    if (round(a,digits = 1) != 0) next
    message(a)
}
#for,while一樣能使用next和break
#while跟repeat很像，但是會檢查while裡面條件為TRUE才會開始執行，直到FALSE為止

#repeat跟while都能相互轉換，如果迴圈執行至少一次就能使用repeat
#while設定主要條件讓程式碼更易於閱讀




#迴圈主要利用'重複動作'的特性，能夠達成許多目的
#讀取資料
for (i in 1:3) {
    x[[i]] <- read.csv(paste0("data/",i,".csv"))
} #一些有條理的資料通常名稱應該長得差不多
#使用list來儲存結果




